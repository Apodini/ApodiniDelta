//
//  File.swift
//  
//
//  Created by Eldi Cano on 07.05.21.
//

import Foundation

/// Distinct file / object types
enum Kind: String {
    case `struct`
    case `class`
    case `enum`
    
    /// Signature of `self`, classes are marked with `final` keyword
    var signature: String {
        "\(self == .class ? "final " : "")\(rawValue)"
    }
}

/// A protocol that template models can conform to
protocol SwiftFileTemplate: Renderable {
    /// The `typeInformation` for which the template will be created
    var typeInformation: TypeInformation { get }
    
    /// The type of the content of the file
    var kind: Kind { get }
    
    /// Initializes a template out of a `TypeInformation`
    /// - Parameter typeInformation: `typeInformation` for which the template will be created
    /// - Parameter kind: swift kind of the object
    /// - Throws: `SwiftFileTemplateError.incompatibleType(message:)` if the template does not support the `typeInformation`
    init(_ typeInformation: TypeInformation, kind: Kind) throws
}

/// Errors that can be thrown from a `SwiftFileTemplate` initializer
enum SwiftFileTemplateError: Error {
    case incompatibleType(message: String)
}

/// Distinct cases of mark comments that might appear in a file
enum MARKCommentType: String {
    case signature
    case codingKeys
    case properties
    case encodable
    case decodable
}

/// `SwiftFileTemplate` default implementations
extension SwiftFileTemplate {
    /// The string of the type name of the `typeInformation`, without the name of the module
    var typeNameString: String {
        typeInformation.typeName.name
    }
    
    /// File extension
    /// - Note: always `.swift`
    var fileExtension: FileExtension { .swift }
    
    /// File name constructed from the type name and the file extension
    var fileName: String { "\(typeNameString).\(fileExtension)" }
    
    /// File comment in the header of the `Swift` file
    var fileComment: String {
        FileHeaderComment(fileName: fileName).render()
    }
    
    /// A function to create a mark comment of a specific type
    /// - Parameters:
    ///    - type: type of the mark comment
    ///    - indentation: indentation to be applied to the comment
    /// - Returns: `MARKComment` instance
    func markComment(_ type: MARKCommentType) -> MARKComment {
        .init(type == .signature ? typeNameString : type.rawValue.upperFirst)
    }
    
    /// Writes the content of `render()` method at the specified path, formatted with `IndentationFormatter`
    /// - Parameter directory: The path of directory where the content should be written
    /// - Throws: if the writing of the content fails
    /// - Returns: absolute path where the file is located
    @discardableResult
    func write(at directory: Path) throws -> Path {
        let absolutePath = directory + fileName
        try absolutePath.write(render().formatted(with: IndentationFormatter.self))
        return absolutePath
    }
}

/// An object that renders the header comment of a `Swift` file generated by `ApodiniMigrator`
private struct FileHeaderComment: Renderable {
    /// Name of the file
    let fileName: String
    
    /// Returns the content of the file header comment
    func render() -> String {
        """
        //
        //  \(fileName)
        //
        //  Created by ApodiniMigrator on \(Date().string(.date))
        //  Copyright \u{00A9} \(Date().string(.year)) TUM LS1. All rights reserved.
        //
        """
    }
}

/// An object representing imports of a Swift file
struct Import: Renderable {
    /// Distinct framework cases that can be imported in `ApodiniMigrator`
    enum Frameworks: String {
        case foundation
        case combine
        case apodiniMigrator
        
        /// String representation of the import
        var string: String {
            "import \(rawValue.upperFirst)"
        }
    }
    
    /// Set of to be imported frameworks
    private var frameworks: Set<Frameworks>
    
    /// Initializes `self` with `frameworks`
    init(_ frameworks: Frameworks...) {
        self.frameworks = Set(frameworks)
    }
    
    /// Inserts `framework`
    mutating func insert(_ framework: Frameworks) {
        frameworks.insert(framework)
    }
    
    /// String represeantion of `frameworks`
    /// One line per framwork, no empty lines in between
    func render() -> String {
        """
        \(frameworks.map { $0.string }.withBreakingLines())
        """
    }
}
