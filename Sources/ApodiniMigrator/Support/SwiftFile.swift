//
// This source file is part of the Apodini open source project
//
// SPDX-FileCopyrightText: 2019-2021 Paul Schmiedmayer and the Apodini project authors (see CONTRIBUTORS.md) <paul.schmiedmayer@tum.de>
//
// SPDX-License-Identifier: MIT
//

import Foundation
import MigratorAPI

/// Distinct file / object types
enum Kind: String { // TODO move into own file!
    case `struct`
    case `class`
    case `enum`
    case `extension`
    
    /// Signature of `self`, classes are marked with `final` keyword
    var signature: String {
        "public \(self == .class ? "final " : "")\(rawValue)"
    }
}

/// Distinct cases of mark comments that might appear in a file
enum MARKCommentType: String { // TODO move to MarkComment!
    case model
    case deprecated
    case codingKeys
    case properties
    case initializer
    case encodable
    case decodable
    case utils
    case endpoints
    
    var comment: String {
        rawValue.upperFirst
    }
}

/// An object that renders the header comment of a `Swift` file generated by `ApodiniMigrator`
public struct FileHeaderComment: RenderableBuilder { // TODO move into own file
    static var testsDate: Date?
    
    public init() {}
    
    /// Returns the content of the file header comment
    public var fileContent: String {
        let date = Self.testsDate ?? .init()

        """
        //
        //  Created by ApodiniMigrator on \(date.string(.date))
        //  Copyright \u{00A9} \(date.string(.year)) TUM LS1. All rights reserved.
        //

        """
    }
}

/// An object representing imports of a Swift file
struct Import: RenderableBuilder { // TODO move into own file!
    /// Distinct framework cases that can be imported in `ApodiniMigrator`
    enum Frameworks: String {
        case foundation
        case combine
        case apodiniMigrator
        case apodiniMigratorClientSupport
        case xCTest
        
        /// String representation of the import
        var string: String {
            "import \(rawValue.upperFirst)"
        }
    }
    
    /// Set of to be imported frameworks
    private var frameworks: Set<String>
    private var testable: Bool
    
    /// Initializes `self` with `frameworks`
    init(_ frameworks: Frameworks..., testable: Bool = false) {
        self.frameworks = Set(frameworks.map { $0.string })
        self.testable = testable
    }

    init(_ frameworks: String..., testable: Bool = false) {
        self.frameworks = Set(frameworks.map { "import " + $0 })
        self.testable = testable
    }
    
    /// Inserts `framework`
    mutating func insert(_ framework: Frameworks, testable: Bool = false) {
        precondition(self.testable == testable)
        frameworks.insert(framework.string)
    }
    
    /// String representation of `frameworks`
    /// One line per framework, no empty lines in between
    var fileContent: String {
        for framework in frameworks.sorted() {
            if testable {
                "@testable \(framework)"
            } else {
                framework
            }
        }
    }
}
